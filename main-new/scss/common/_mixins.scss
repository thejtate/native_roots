@mixin text-hide($type: default) {
  text-indent: -9999px;
  font-size: 0;
  line-height: 0;
}

@mixin clear-box {
  clear: both;
  overflow: hidden;
}

@mixin inline {
  display: inline-block;
  vertical-align: top;
  *display: inline;
  *zoom: 1;
  *text-indent: 0 !important;
}

@mixin retina-sprite($name, $hover: false, $active: false) {
  @include _retina-sprite($name, $icons, $icons2, $hover, $active);
}

// The general purpose retina sprite mixin.
//
//    @include retina-sprite(name, $spritemap1, $spritemap2)
//    @include retina-sprite(name, $spritemap1, $spritemap2[, $dimensions: true, $pad: 0])
//
//    If `dimensions` is true, then width/height will also be set.
//
//    if `pad` is non-zero, then that's how much padding the element will have (requires
//    $spacing on the sprite maps). Great for iPhone interfaces to make hit areas bigger.
//
@mixin _retina-sprite($name, $icons, $icons2, $hover, $active, $dimensions: true, $pad: 0) {
  @if $dimensions == true {
    @include sprite-dimensions($icons, $name);
  }
  background-image: sprite-url($icons);
  background-position: sprite-position($icons, $name, -$pad, -$pad);
  background-repeat: no-repeat;

  @if $hover == true {
    $name_hover: $name + _hover;
    &:hover {
      background-position: sprite-position($icons, $name_hover, -$pad, -$pad);
    }
  }
  @if $active == true {
    $name_active: $name + _active;
    &:active {
      background-position: sprite-position($icons, $name_active, -$pad, -$pad);
    }
  }

  @if $pad > 0 {
    padding: $pad;
  }

  @media (-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-device-pixel-ratio: 1.5), (min-resolution: 144dpi) {
    & {
      $pos: sprite-position($icons2, $name, -$pad * 2, -$pad * 2);
      background-image: sprite-url($icons2);
      background-position: nth($pos, 1) / 2 nth($pos, 2) / 2;
      @include background-size(ceil(image-width(sprite-path($icons2)) / 2) auto);
      //  sprite-path() returns the path of the generated sprite sheet, which
      //  image-width() calculates the width of. the ceil() is in place in case
      //  you have sprites that have an odd-number of pixels in width

      @if $hover == true {
        $name_hover: $name + _hover;    // create myButton_hover and assign it
        &:hover{
          $pos: sprite-position($icons2, $name_hover, -$pad * 2, -$pad * 2);
          background-position: nth($pos, 1) / 2 nth($pos, 2) / 2;
        }
      }
      @if $active == true {
        $name_active: $name + _active;    // create myButton_active and assign it
        &:active{
          $pos: sprite-position($icons2, $name_active, -$pad * 2, -$pad * 2);
          background-position: nth($pos, 1) / 2 nth($pos, 2) / 2;
        }
      }
    }
  }
}

@mixin oneline-sprite($map, $name, $repeat: no-repeat, $bg-color: '') {
  background: #{$bg-color} sprite-url($map) sprite-position($map, $name) #{$repeat};
}

@mixin oneline-sprite-box($map, $name, $repeat: no-repeat, $bg-color: '', $text: true) {
  @if $text != true {
    @include hide-text;
  }
  @include sprite-dimensions($map, $name);
  @include oneline-sprite($map, $name, $repeat, $bg-color);
}

@mixin pseudo-block($top: false, $right: false, $bottom: false, $left: false, $position: absolute) {
  content: "";
  
  @if ($position == relative) {
    @include inline;
  }
  @else {
    display: block;
  }
  
  position: $position;
  
  @if ($top) {
    top: $top;
  }
  @if ($right) {
    right: $right;
  }
  @if ($bottom) {
    bottom: $bottom;
  }
  @if ($left) { 
    left: $left; 
  }
}

@mixin clearfix($pseudo: true) {
  $after: '&:after';
  
  @if $pseudo == false {
    $after: '.after-clearfix';
    suffix: -clearfix;
    after: ' ';
  }
  
  #{$after} { 
    content: " ";
    display: block;
    height: 0;
    clear: both;
    overflow: hidden;
    visibility: hidden;
  }
}

@mixin input-placeholder($color) {
  &.placeholder {
    color: $color;
  }
  &:-moz-placeholder {
    color: $color;
  }
  &::-webkit-input-placeholder {
    color: $color;
  }
}

@mixin font-size-em($pxval, $baseline : $base_fs_px) {
  font-size: ($pxval / $baseline) * 1em
}

@mixin transparent($color, $alpha) {
  $rgba: rgba($color, $alpha);
  $ie-hex-str: ie-hex-str($rgba);
  background-color: transparent;
  background-color: $rgba;
  filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#{$ie-hex-str},endColorstr=#{$ie-hex-str});
  zoom: 1;
}

@function calculateRem($size) {
  $remSize: $size / 10px;
  @return #{$remSize}rem;
}

@mixin style-size($size, $style, $important: false) {
  @if ($important) {
    #{$style}: $size!important;
    #{$style}: calculateRem($size)!important;
  } @else {
    #{$style}: $size;
    #{$style}: calculateRem($size);
  }
}